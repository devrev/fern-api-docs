## Complete the chef-cli initial domain mapping setup

Next, continue with the steps outlined in [chef-cli setup](initial_domain_mapping_setup.md). 

When you are done you should have the chef-cli context set up and have the chef-cli local UI running in your browser.

## Use the local UI to create initial domain mappings

The final artifact of the recipe creation process is the `initial_domain_mapping.json`, which has to be embedded in the extractor.

This mapping, unlike the recipe blueprint of a concrete import, can contain multiple options for each external record type from which the end-user might choose (for example allow 'task' from an external system to map either to issue or ticket in DevRev), and it can contain also mappings that apply to a record type category. When the user runs a new import, and the extractor reports in its metadata record types belonging to this category, that are not directly mapped in the initial domain mappings, the recipe manager will apply the per-category default to them.

After the blueprint of the test import was completed, the 'install in this org' button takes you to the initial domain mapping creation screen, where you can 'merge' the blueprint to the existing initial mappings of the org.

By repeating this process (run a new import, create a different configuration, merge to the initial mappings), you can create an initial mapping that contains multiple options for the user to choose from.

Finally the Export button allows you to retrieve the `initial_domain_mapping.json`.

## Tip: use local metadata in the local UI

You can also provide a local metadata file to the command using the '-m' flag for example: `chef-cli configure-mappings --env prod -m metadata.json`, this enables to use:

- raw jq transformations using an external field as input. (This is an experimental feature)

- filling in example input data for trying out the transformation.

In this case it is not validated that the local file is the same as the one submitted by the snap-in, this has to be ensured by you.

## Test an import with initial mapping using the in-app UI.

Once the initial mappings are prepared and, any new import in the org (with the same snap-in slug and import slug) where they are installed will use them. The end-users can influence the recipe blueprint that gets created for the sync unit trough the mapping screen in the UI, where they can make record-type filtering, mapping, fine grained filtering, low-code field and value mapping, and finally custom field filtering.

Their decisions are constrained by the choices provided in the initial domain mappings. Currently the low-code UI offers limited insight into the mappings and their reasons, and in some cases, mismatches arise when something that worked in chef-cli doesn't offer the right options to the user, or not all fields that should be resolved are solved. To assist debugging such cases, chef-cli provides a command to extract the description of the low-code decisions that are asked in the UI. Please provide this to us when reporting an issue with how the end-user mapping UI behaves.

```bash
chef-cli low-code --env prod > low_code.json`
```
 
## Read metadata tips to improve the metadata

See the [metadata tips](tips.md) section for more information on how to improve the metadata.
