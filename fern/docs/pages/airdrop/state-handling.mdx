# Snap-in `state`

Since each snap-in invocation is a separate runtime instance, it does not know what has been previously accomplished.

To enable information passing between invocations and runs we have added support for saving a limited amount of data as snap-in `state`.

* Snap-in's `state` is loaded at the start of each invocation and saved at its end. 
* Each sync direction (to DevRev and from DevRev) has its own `state` object that is not shared.
* Snap-in `state` should be smaller than 1 MB.Hard cap is a bit higher. 1 MB maps to approximately 500 000 characters.

Effective use of the `state` and breaking down the problem into smaller chunks is crucial for good performance and user experience.

Without knowing what has been processed, the snap-in will extract the same data multiple times, using precious API capacity, time, and posibly duplicate the data inside DevRev or the external application. Duplicate data will lead to frustrating snap-in user experience.

# Data queries

First step is to research the external system of records (SOR) public API capabilities.

* Does it offer searching on created date, modified date, some append only change log?
* How do records relate to each other, can I query them independantly?
* Do records contain parent and/or children information.
* Does a list call return only a summary or all needed information. Do I need to create separate calls to retrieve more than X comments, or threaded comments?
* How many documents does a list call return? Is it best to limit them due to low API limits?

# Example system

Lets define the limits of a theoretical system:

* Allows list queries by the changed date that returns 50 items in one batch.
* Each item contains up to 10 comments, for more you need to use a different API endpoint.
* Retrieved item contains a flag indicating the existence of attachments.

This simple system has a straightforward data template with a few API limits.

* Parent item can be retrieved with a list call. 
* If the parent contains 10 comments, we have to perform a separate call to see if more comments exist.
* In the separate attachment phase we have to list though items again and extract attachments from those that exist.
* We cannot save all the IDs of parent objects with attachments as that could breach `state` size limits.
* It is best for the `state` to contain last changed date timestamp plus some item IDs in case multiple items were changed at the same time. All 50 item IDs could easily fit in the `state`.
* Between list calls some items can be updated. Two queries with the same changed date might not return the same items.

# Set the `state`

In our theoretical system we would be able to batch calls in the increments of 50.

* In each batch we would extract items and all of their comments.

After each batch is processed, changed date, item IDs and the changed date of the last seen item is saved in the `state`.
In the next batch we can use the changed date of the last seen item as the starting point. If we are afraid to lose some items, we can always decrement the smallest time chunk the platform supports to make sure some items overlap from one batch to another.
We also have to make sure to not trap ourselves into the cycle to always call with the same changed date and forever retrieve the same items.

In the same way as we determined to use changed date as a discriminator between chunks we have to make sure we can use an indicator to continue between invocation and between sync runs.

**As we have to list through all items to extract attachments, we need to make sure that we do not override the changed date and item IDs state between attachment and data phase themselves**.