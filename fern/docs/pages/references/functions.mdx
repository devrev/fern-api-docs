Using functions, you can provide custom code and link it to your event sources, automations, or snap-kit actions. Functions are written in JavaScript and can be used to transform events, send notifications, or perform any other custom logic including network calls.

In order to create a snap-in version, functions must be defined as shown in the [code samples](/snapin-development/code-samples). Functions are packaged and provided as an artifact at the time of snap-in version creation and then used to deploy functions to snap-in versions. An artifact may contain multiple function definitions. The artifact is a zip file containing the following files:


```bash
/
├── src/
├ ├── functions/ # Contains a folder each for the functions defined in the manifest. The folder name should match the function name in manifest.
├ ├── functions/function-1/ # function-1 is a function defined in the manifest.
├ ├── function-factory.ts # defines the functions to be imported. Each function to be used in the manifest should be included here. Refer to the example for the format.
├── dist/ # Contains the transpiled code for the functions. Autogenerated but should be included in the artifact.
├── package.json # Contains the dependencies for the functions.

```

## Function manifest

The function manifest consists of the following fields:

```yaml
functions:
  - name: function_1
    description: Function 1
```

- `name`: It is the function name that should match the corresponding function name in the folder.
- `description`: It describes the function.

### Synchronous execution with synchronization key

To ensure that function executions are processed in order, FIFO, for a given context such as a user or conversation, enable synchronization support in your function’s manifest and use a synchronization key, sync_id.

The platform uses the sync_id as the message group for FIFO processing. This ensures that all executions with the same sync_id are processed in order, preventing race conditions or duplicate conversations.
Use cases for synchronous execution include:

- Ensuring order of message processing for chatbots or messaging integrations.
- Preventing duplicate or out-of-order actions when multiple events are triggered.

To enable this: 

1. Enable synchronization in manifest
   - In your function’s manifest, add the field:
     ```yaml
     functions:
      - name: function_name
        description: Let me execute
        supports_synchronization: true
     ```
   - This tells the platform to use a FIFO queue for this function.

1. Set the synchronization key
   - When triggering an automation, include the sync_id in your rego policy along with the `event_key`. For example:
     ```rego rego
     package rego

     output = {"event": event, "event_key": event_key, "sync_id": sync_id} {
         input.request.method == "POST"
         event := input.request.body
         event_key := "user-enter"
         sync_id := "1234567890"
     } else = {"response": response }{
         response := {
             "status_code": 400
         }
     }
     ```

   - The sync_id groups related executions for ordered processing.

3. Execution behavior
   - If `supports_synchronization` is true and a sync_id is provided, executions with the same sync_id are processed in order.
   - If no sync_id is provided, executions are grouped by a random string.
   - If `supports_synchronization` is false, the sync_id is ignored and executions are processed as usual.


<Callout intent="note">
Each function should be registered in `src/function-factory.ts` to be available for execution.
</Callout>

Refer to the [function invocation](/snapin-development/references/function-invocation) for details about the exact payload of the function.
