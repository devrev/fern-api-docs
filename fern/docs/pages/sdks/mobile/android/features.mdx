# Features

## Identification

To access certain features of the DevRev SDK, user identification is required.

The identification function should be placed appropriately in your app after the user logs in. If you have the user information available at app launch, call the function after the `DevRev.configure(context, appID)` method.

<Callout intent="tip">
The `Identity` structure allows for custom fields in the user, organization, and account traits. These fields must be configured through the DevRev app before they can be utilized. For more information, refer to [Object customization](https://devrev.ai/docs/product/object-customization).
</Callout>

### Identify an anonymous user

The anonymous identification method allows you to create an anonymous user with an optional user identifier, ensuring that no other data is stored or associated with the user.

<Tabs>
  <Tab title="Kotlin">
    ```kotlin
    DevRev.identifyAnonymousUser(
      userId: String
    )
    ```
  </Tab>
  <Tab title="Java">
    ```java
    DevRev.INSTANCE.identifyAnonymousUser(
      String userId
    );
    ```
  </Tab>
</Tabs>

### Identify an unverified user

The unverified identification method identifies users with a unique identifier, but it does not verify their identity with the DevRev backend.

<Tabs>
  <Tab title="Kotlin">
    ```kotlin
    DevRev.identifyUnverifiedUser(
      identity: Identity
    )
    ```
  </Tab>
  <Tab title="Java">
    ```java
    DevRev.INSTANCE.identifyUnverifiedUser(
      Identity identity
    );
    ```
  </Tab>
</Tabs>

The function accepts the `DevRev.Identity` structure, with the user identifier (`userID`) as the only required property, all other properties are optional.

For example:

<Tabs>
  <Tab title="Kotlin">
    ```kotlin
    // Identify an unverified user using their email address as the user identifier.
    DevRev.identifyUnverifiedUser(Identity(userId = "user@example.org"))
    ```
  </Tab>
  <Tab title="Java">
    ```java
    // Identify an unverified user using their email address as the user identifier.
    DevRev.identifyUnverifiedUser(
        new Identity("user@example.org", null, null, null, null, null)
    );
    ```
  </Tab>
</Tabs>

### Identify a verified user

The verified identification method is used to identify users with an identifier unique to your system within the DevRev platform. The verification is done through a token exchange process between you and the DevRev backend.

The steps to identify a verified user are as follows:
1. Generate an AAT for your system (preferably through your backend).
2. Exchange your AAT for a session token for each user of your system.
3. Pass the user identifier and the exchanged session token to the `DevRev.identifyVerifiedUser(userId: String, sessionToken: String)` method.

<Callout intent="warning">
For security reasons, it is **strongly recommended** that the token exchange is executed on your backend to prevent exposing your application access token (AAT).
</Callout>

#### Generate an AAT

1. Open the DevRev web app at [https://app.devrev.ai](https://app.devrev.ai) and go to the **Settings** page.
2. Open the **Plug Tokens** page.
3. Under the **Application access tokens** panel, click **New token** and copy the token that's displayed.

<Callout intent="warning">
Ensure that you copy the generated application access token, as you cannot view it again.
</Callout>

#### Exchange your AAT for a session token

To proceed with identifying the user, you need to exchange your AAT for a session token. This step helps you identify a user of your own system within the DevRev platform.

Here is a simple example of an API request to the DevRev backend to exchange your AAT for a session token:

<Callout intent="warning">
Make sure that you replace the `<AAT>` and `<YOUR_USER_ID>` with the actual values.
</Callout>

```bash
curl \
--location 'https://api.devrev.ai/auth-tokens.create' \
--header 'accept: application/json, text/plain, */*' \
--header 'content-type: application/json' \
--header 'authorization: <AAT>' \
--data '{
  "rev_info": {
  "user_ref": "<YOUR_USER_ID>"
  }
}'
```

The response of the API call contains a session token that you can use with the verified identification method in your app.

<Callout intent="warning">
As a good practice, **your** app should retrieve the exchanged session token from **your** backend at app launch or any relevant app lifecycle event.
</Callout>

#### Identify the verified user

Pass the user identifier and the exchanged session token to the verified identification method:

<Tabs>
  <Tab title="Kotlin">
    ```kotlin
    DevRev.identifyVerifiedUser(userId: String, sessionToken: String)
    ```
  </Tab>
  <Tab title="Java">
    ```java
    DevRev.INSTANCE.identifyVerifiedUser(String userId, String sessionToken);
    ```
  </Tab>
</Tabs>

### Updating the user

To update a user's information, use the following method:

<Tabs>
  <Tab title="Kotlin">
    ```kotlin
    DevRev.updateUser(
      identity: Identity
    )
    ```
  </Tab>
  <Tab title="Java">
    ```java
    DevRev.INSTANCE.updateUser(
      Identity identity
    );
    ```
  </Tab>
</Tabs>

The function accepts the `DevRev.Identity` ojbect.

<Callout intent="warning">
The `userID` property cannot be updated.
</Callout>

### Logout

You can perform a logout of the current user by calling the following method:

<Tabs>
  <Tab title="Kotlin">
    ```kotlin
    DevRev.logout(context: Context, deviceId: String)
    ```
  </Tab>
  <Tab title="Java">
    ```java
    DevRev.logout(context: Context, deviceId: String)
    ```
  </Tab>
</Tabs>

The user is logged out by clearing their credentials, as well as unregistering the device from receiving push notifications, and stopping the session recording.

### Identity model

The `Identity` class is used to provide user, organization, and account information when identifying users or updating their details. This class is used primarily with the `identifyUnverifiedUser(identity: Identity)` and `updateUser(identity: Identity)` methods.

#### Properties

The `Identity` class contains the following properties:

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `userID` | `String` | ✅ | A unique identifier for the user |
| `organizationID` | `String?` | ❌ | An identifier for the user's organization |
| `accountID` | `String?` | ❌ | An identifier for the user's account |
| `userTraits` | `UserTraits?` | ❌ | Additional information about the user |
| `organizationTraits` | `OrganizationTraits?` | ❌ | Additional information about the organization |
| `accountTraits` | `AccountTraits?` | ❌ | Additional information about the account |

<Callout intent="note">
The custom fields properties defined as part of the user, organization and account traits, must be configured in the DevRev web app **before** they can be used. See [Object customization](https://devrev.ai/docs/product/object-customization) for more information.
</Callout>

##### User traits

The `UserTraits` class contains detailed information about the user:

<Callout intent="note">
All properties in `UserTraits` are optional.
</Callout>

| Property | Type | Description |
|----------|------|-------------|
| `displayName` | `String?` | The displayed name of the user |
| `email` | `String?` | The user's email address |
| `fullName` | `String?` | The user's full name |
| `userDescription` | `String?` | A description of the user |
| `phoneNumbers` | `[String]?` | Array of the user's phone numbers |
| `customFields` | `[String: Any]?` | Dictionary of custom fields configured in DevRev |

##### Organization traits

The `OrganizationTraits` class contains detailed information about the organization:

<Callout intent="note">
All properties in `OrganizationTraits` are optional.
</Callout>

| Property | Type | Description |
|----------|------|-------------|
| `displayName` | `String?` | The displayed name of the organization |
| `domain` | `String?` | The organization's domain |
| `organizationDescription` | `String?` | A description of the organization |
| `phoneNumbers` | `[String]?` | Array of the organization's phone numbers |
| `tier` | `String?` | The organization's tier or plan level |
| `customFields` | `[String: Any]?` | Dictionary of custom fields configured in DevRev |

##### Account traits

The `AccountTraits` class contains detailed information about the account:

<Callout intent="note">
All properties in `AccountTraits` are optional.
</Callout>

| Property | Type | Description |
|----------|------|-------------|
| `displayName` | `String?` | The displayed name of the account |
| `domains` | `[String]?` | Array of domains associated with the account |
| `accountDescription` | `String?` | A description of the account |
| `phoneNumbers` | `[String]?` | Array of the account's phone numbers |
| `websites` | `[String]?` | Array of websites associated with the account |
| `tier` | `String?` | The account's tier or plan level |
| `customFields` | `[String: Any]?` | Dictionary of custom fields configured in DevRev |

## Plug support chat

Once user identification is complete, you can start using the chat (conversations) dialog supported by our DevRev SDK. To open the chat dialog, your application should use the `showSupport` API, as shown in the following example:

<Tabs>
  <Tab title="Kotlin">
    ```kotlin
    DevRev.showSupport(context: Context)
    ```
  </Tab>
  <Tab title="Java">
    ```java
    DevRevExtKt.showSupport(DevRev.INSTANCE, context);
    ```
  </Tab>
</Tabs>

### Create a new conversation

You have the ability to create a new conversation from within your app. The method shows the support chat screen and creates a new conversation at the same time.

<Tabs>
  <Tab title="Kotlin">
    ```kotlin
    DevRev.createSupportConversation(context: Context)
    ```
  </Tab>
  <Tab title="Java">
    ```java
    DevRev.INSTANCE.createSupportConversation(context);
    ```
  </Tab>
</Tabs>

### Support button

The DevRev SDK also provides a support button, which can be integrated into your application. To include it on the current screen, add the following code to your XML layout:

```xml
<ai.devrev.sdk.plug.view.PlugFloatingActionButton
  android:id="@+id/plug_fab"
  android:layout_width="wrap_content"
  android:layout_height="wrap_content"
  android:layout_margin="24dp"
  app:layout_constraintBottom_toBottomOf="parent"
  app:layout_constraintEnd_toEndOf="parent" />
```

The support button can be customized using default parameters, enabling you to tailor its appearance to your application's design:

```xml
android:src="@your_drawable_here"
android:backgroundTint="@your_background_color"
```

## In-app link handling

The DevRev SDK provides a mechanism to handle links opened from within any screen that is part of the DevRev SDK.

You can fully customize the link handling behavior by setting the specialized in-app link handler. That way you can decide what should happen when a link is opened from within the app.

<Tabs>
  <Tab title="Kotlin">
    ```kotlin
    DevRev.setInAppLinkHandler(handler: (String) -> Unit)
    ```
  </Tab>
  <Tab title="Java">
    ```java
    DevRev.INSTANCE.setInAppLinkHandler(Function1<String, Unit> handler);
    ```
  </Tab>
</Tabs>

You can further customize the behavior by setting the `setShouldDismissModalsOnOpenLink` boolean flag. This flag controls whether the DevRev SDK should dismiss the top-most modal screen when a link is opened.

<Tabs>
  <Tab title="Kotlin">
    ```kotlin
    DevRev.setShouldDismissModalsOnOpenLink(value: boolean)
    ```
  </Tab>
  <Tab title="Java">
    ```java
    DevRev.INSTANCE.setShouldDismissModalsOnOpenLink(boolean value)
    ```
  </Tab>
</Tabs>

For example:

<Tabs>
  <Tab title="Kotlin">
    ```kotlin
    DevRev.setInAppLinkHandler { link ->
      // Do something here
    }

    DevRev.setShouldDismissModalsOnOpenLink(false)
    ```
  </Tab>
  <Tab title="Java">
    ```java
    DevRev.INSTANCE.setInAppLinkHandler(link -> {
      // Do something here
      return kotlin.Unit.INSTANCE;
    });

    DevRev.INSTANCE.setShouldDismissModalsOnOpenLink(false);
    ```
  </Tab>
</Tabs>

## Dynamic theme configuration

The DevRev SDK allows you to configure the theme dynamically based on the system appearance, or use the theme configured on the DevRev portal. By default, the theme is dynamic and follows the system appearance.

<Tabs>
  <Tab title="Kotlin">
    ```kotlin
    DevRev.setShouldPreferSystemTheme(value: Boolean)
    ```
  </Tab>
  <Tab title="Java">
    ```java
    DevRev.INSTANCE.setShouldPreferSystemTheme(boolean value);
    ```
  </Tab>
</Tabs>

## Analytics

The DevRev SDK allows you to send custom analytic events by using a name and a string dictionary. You can track these events using the following function:

<Tabs>
  <Tab title="Kotlin">
    ```kotlin
    DevRev.trackEvent(name: String, properties: HashMap<String, String>)
    ```
  </Tab>
  <Tab title="Java">
    ```java
    DevRevAnalyticsExtKt.trackEvent(DevRev instance, String name, HashMap<String, String> properties);
    ```
  </Tab>
</Tabs>

For example:

<Tabs>
  <Tab title="Kotlin">
    ```kotlin
    DevRev.trackEvent(name = "open-message-screen", properties = {"id": "message-1337"})
    ```
  </Tab>
  <Tab title="Java">
    ```java
    DevRevAnalyticsExtKt.trackEvent(DevRev.INSTANCE, "open-message-screen", new HashMap<>().put("id", "message-1337"));
    ```
  </Tab>
</Tabs>

## Session analytics

The DevRev SDK provides observability features to help you understand how your users are interacting with your app.

### Opt in or out

Session analytics features are opted-in by default, enabling them from the start. However, you can opt-out using the following method:

<Tabs>
  <Tab title="Kotlin">
    ```kotlin
    DevRev.stopAllMonitoring()
    ```
  </Tab>
  <Tab title="Java">
    ```java
    DevRevObservabilityExtKt.stopAllMonitoring(DevRev.INSTANCE);
    ```
  </Tab>
</Tabs>

To opt back in, use the following method:

<Tabs>
  <Tab title="Kotlin">
    ```kotlin
    DevRev.resumeAllMonitoring()
    ```
  </Tab>
  <Tab title="Java">
    ```java
    DevRevObservabilityExtKt.resumeAllMonitoring(DevRev.INSTANCE);
    ```
  </Tab>
</Tabs>

You can check whether session monitoring has been enabled by using this property:

<Tabs>
  <Tab title="Kotlin">
    ```kotlin
    DevRev.isMonitoringEnabled
    ```
  </Tab>
  <Tab title="Java">
    ```java
    DevRevObservabilityExtKt.isMonitoringEnabled(DevRev.INSTANCE);
    ```
  </Tab>
</Tabs>

<Callout intent="note">
This feature will only store a monitoring permission flag, it will **not** provide any UI or dialog.
</Callout>

### Session recording

You can enable session recording to capture user interactions with your app.

<Callout intent="note">
The session recording feature is opt-out and is enabled by default.
</Callout>

Here are the available methods to help you control the session recording feature:

<Tabs>
  <Tab title="Kotlin">
   | Method | Action |
   |-|-|
   |`DevRev.startRecording()` | Starts the session recording. |
   |`DevRev.stopRecording()` | Ends the session recording and uploads it to the portal. |
   |`DevRev.pauseRecording()` | Pauses the ongoing session recording. |
   |`DevRev.resumeRecording()` | Resumes a paused session recording. |
   |`DevRev.processAllOnDemandSessions()` | Stops the ongoing user recording and sends all on-demand sessions along with the current recording. |
  </Tab>
  <Tab title="Java">
   | Method | Action |
   |-|-|
   | `DevRevObservabilityExtKt.startRecording(DevRev.INSTANCE, context)` | Starts the session recording. |
   | `DevRevObservabilityExtKt.stopRecording(DevRev.INSTANCE)` | Ends the session recording and uploads it to the portal. |
   | `DevRevObservabilityExtKt.pauseRecording(DevRev.INSTANCE)` | Pauses the ongoing session recording. |
   | `DevRevObservabilityExtKt.resumeRecording(DevRev.INSTANCE)` | Resumes a paused session recording. |
   | `DevRevObservabilityExtKt.processAllOnDemandSessions(DevRev.INSTANCE)` | Stops the ongoing user recording and sends all on-demand sessions along with the current recording. |
  </Tab>
</Tabs>

Using this property returns the status of the session recording:

<Tabs>
  <Tab title="Kotlin">
    ```kotlin
    DevRev.isRecording
    ```
  </Tab>
  <Tab title="Java">
    ```java
    DevRevObservabilityExtKt.isRecording(DevRev.INSTANCE);
    ```
  </Tab>
</Tabs>

To check if on-demand sessions are enabled, use:

<Tabs>
  <Tab title="Kotlin">
    ```kotlin
    DevRev.areOnDemandSessionsEnabled
    ```
  </Tab>
  <Tab title="Java">
    ```java
    DevRevObservabilityExtKt.areOnDemandSessionsEnabled(DevRev.INSTANCE);
    ```
  </Tab>
</Tabs>

### Session properties

You can add custom properties to the session recording to help you understand the context of the session. The properties are defined as a dictionary of string values.

<Tabs>
  <Tab title="Kotlin">
    ```kotlin
    DevRev.addSessionProperties(properties: HashMap<String, String>)
    ```
  </Tab>
  <Tab title="Java">
    ```java
    DevRevObservabilityExtKt.addSessionProperties(DevRev.INSTANCE, HashMap<String, String> properties);
    ```
  </Tab>
</Tabs>

To clear the session properties in scenarios such as user logout or when the session ends, use the following method:

<Tabs>
  <Tab title="Kotlin">
    ```kotlin
    DevRev.clearSessionProperties()
    ```
  </Tab>
  <Tab title="Java">
    ```java
    DevRevObservabilityExtKt.clearSessionProperties(DevRev.INSTANCE);
    ```
  </Tab>
</Tabs>

### Mask sensitive data

To protect sensitive data, the DevRev SDK provides an auto-masking feature that masks data before sending to the server. Input views such as text fields, text views, and web views are automatically masked.

While the auto-masking feature may be sufficient for most situations, you can manually mark/unmark additional views as sensitive.

The SDK provides two approaches to manually mask or unmask your views, using a set of predefined tags or using the API methods.

#### Mask using predefined tags

<Callout intent="tip">
Use the tag method only when you don't have any other tag already applied to your UI element.
</Callout>

Masking views using the predefined tags is the simplest way to mask your views, use the tag `devrev-mask` to mask a view and `devrev-unmask` to unmask a view.

- Mark a view as masked:
  ```xml
  android:tag="devrev-mask"
  ```

- Mark a view as unmasked:
  ```xml
  android:tag="devrev-unmask"
  ```

For example:

```xml
<!-- A masked web view -->
<WebView
  android:id="@+id/webview1"
  android:layout_width="fill_parent"
  android:layout_height="200dp"
  android:background="@android:color/transparent"
  android:tag="devrev-mask" />

<!-- An unmasked web view -->
<WebView
  android:id="@+id/webview2"
  android:layout_width="fill_parent"
  android:layout_height="200dp"
  android:background="@android:color/transparent"
  android:tag="devrev-unmask" />
```

The tags can also be set programmatically:

<Tabs>
  <Tab title="Kotlin">
  - Mark a view as masked:
    ```kotlin
    val firstView: View = findViewById(R.id.firstView)
    firstView.tag = "devrev-mask"
    ```
  - Mark a view as unmasked:
    ```kotlin
    val secondView: View = findViewById(R.id.secondView)
    secondView.tag = "devrev-unmask"
    ```
  </Tab>
  <Tab title="Java">
  - Mark a view as masked:
    ```java
    View firstView = findViewById(R.id.firstView);
    firstView.setTag("devrev-mask");
    ```
  - Mark a view as unmasked:
    ```java
    View secondView = findViewById(R.id.secondView);
    secondView.setTag("devrev-unmask");
    ```
  </Tab>
</Tabs>

#### Mask using the API methods

You can also use the API methods to mask or unmask your views programmatically.

<Tabs>
  <Tab title="Kotlin">
  - Mark a view as masked:
    ```kotlin
    DevRev.markSensitiveViews(sensitiveViews: List<View>)
    ```
  - Mark a view as unmasked:
    ```kotlin
    DevRev.unmarkSensitiveViews(sensitiveViews: List<View>)
    ```
  </Tab>
  <Tab title="Java">
  - Mark a view as masked:
    ```java
    DevRevObservabilityExtKt.markSensitiveViews(DevRev.INSTANCE, List<View> sensitiveViews);
    ```
  - Mark a view as unmasked:
    ```java
    DevRevObservabilityExtKt.unmarkSensitiveViews(DevRev.INSTANCE, List<View> sensitiveViews);
    ```
  </Tab>
</Tabs>

For example:

<Tabs>
  <Tab title="Kotlin">
    ```kotlin
    // Mark two views as masked.

    val view1 = findViewById(R.id.view1)
    val view2 = findViewById(R.id.view2)

    DevRev.markSensitiveViews(listOf(view1, view2))

    // Mark two views as unmasked.

    val view3 = findViewById(R.id.view3)
    val view4 = findViewById(R.id.view4)

    DevRev.unmarkSensitiveViews(listOf(view3, view4))
    ```
  </Tab>
  <Tab title="Java">
    ```java
    // Mark two views as masked.

    View view1 = findViewById(R.id.view1);
    View view2 = findViewById(R.id.view2);

    List<View> sensitiveViewsList = new ArrayList<>();
    sensitiveViewsList.add(view1);
    sensitiveViewsList.add(view2);

    DevRevObservabilityExtKt.markSensitiveViews(DevRev.INSTANCE, sensitiveViewsList);

    // Mark two views as unmasked.

    View view3 = findViewById(R.id.view3);
    View view4 = findViewById(R.id.view4);

    List<View> sensitiveViewsList = new ArrayList<>();
    sensitiveViewsList.add(view3);
    sensitiveViewsList.add(view4);

    DevRevObservabilityExtKt.unmarkSensitiveViews(DevRev.INSTANCE, sensitiveViewsList);
    ```
  </Tab>
</Tabs>

#### Mask Jetpack Compose views

If you want to mask any Jetpack Compose UI elements or views, you can apply a mask on it using a modifier.

```kotlin
modifier = Modifier.markAsMaskedLocation("VIEW_NAME_OR_ID")
```

For example:

```kotlin
TextField(
     modifier = Modifier
       .markAsMaskedLocation("myTextField")
       .padding(horizontal = 20.dp)
       .onGloballyPositioned { coordinates = it },
     value = input,
     onValueChange = { input = it }
)
```

#### Mask elements inside web views

Masking elements inside web views (`WebView`) can be achieved by using the CSS class `devrev-mask` to mask an element and `devrev-unmask` to unmask an element.

- Mark an element as masked:
  ```html
  <label class="devrev-mask">OTP: 12345</label>
  ```
- Mark an element as unmasked:
  ```html
  <input type="text" placeholder="Enter Username" name="username" required class="devrev-unmask">
  ```

#### Custom masking provider

For advanced use cases, you can provide a custom masking provider to explicitly specify which regions of the UI should be masked during snapshots.

You can implement your own masking logic by creating a class that implements the `MaskLocationProvider` interface and setting your custom object as the masking provider. This allows you to specify explicit regions to be masked or to skip snapshots entirely.

| Symbol | Description |
|-|-|
|`DevRev.setMaskLocationProvider(maskLocationProvider: MaskLocationProvider)`|A custom provider that determines which UI regions should be masked for privacy during snapshots (this overrides any previously set provider).|
|`MaskLocationProvider`|An interface for providing explicit masking locations for UI snapshots.|
|`SnapshotMask`|An object that describes the regions of a snapshot to be masked.|
|`SnapshotMask.Location`|An object that describes a masked region.|

For example:

<Tabs>
  <Tab title="Kotlin">
    ```kotlin
    import com.userexperior.bridge.model.MaskLocationProvider
    import com.userexperior.bridge.model.SnapshotMask
    import com.userexperior.bridge.model.SnapshotMask.Location
    import ai.devrev.sdk.DevRev

    class MyMaskingProvider : MaskLocationProvider {
      override fun provideSnapshotMask(): SnapshotMask {
        val region = SnapshotMask.Location(x = 10, y = 10, width = 100, height = 40)
        return SnapshotMask(
          locations = listOf(region),
          shouldSkip = false
        )
      }
    }

    DevRev.setMaskLocationProvider(MyMaskingProvider())
    ```
  </Tab>
  <Tab title="Java">
    ```java
    import com.userexperior.bridge.model.MaskLocationProvider;
    import com.userexperior.bridge.model.SnapshotMask;
    import com.userexperior.bridge.model.SnapshotMask.Location;
    import ai.devrev.sdk.DevRev;

    public class MyMaskingProvider implements MaskLocationProvider {
      @Override
      public SnapshotMask provideSnapshotMask() {
        Location region = new Location(10, 10, 100, 40);
        return new SnapshotMask(
          Arrays.asList(region),
          false
        );
      }
    }

    DevRev.setMaskLocationProvider(new MyMaskingProvider());
    ```
  </Tab>
</Tabs>

<Callout intent="tip">
Setting a new provider overrides any previously set masking location provider.
</Callout>

### Timers

The DevRev SDK offers a timer mechanism to measure the time spent on specific tasks, allowing you to track events such as response time, loading time, or any other duration-based metrics.

The mechanism works using balanced start and stop methods that both accept a timer name and an optional dictionary of properties.

To start a timer, use the following method:

<Tabs>
  <Tab title="Kotlin">
    ```kotlin
    DevRev.startTimer(name: String, properties: HashMap<String, String>)
    ```
  </Tab>
  <Tab title="Java">
    ```java
    DevRevObservabilityExtKt.startTimer(DevRev.INSTANCE, String name, HashMap<String, String> properties);
    ```
  </Tab>
</Tabs>

To stop a timer, use the following method:

<Tabs>
  <Tab title="Kotlin">
    ```kotlin
    DevRev.endTimer(name: String, properties: HashMap<String, String>)
    ```
  </Tab>
  <Tab title="Java">
    ```java
    DevRevObservabilityExtKt.endTimer(DevRev.INSTANCE, String name, HashMap<String, String> properties);
    ```
  </Tab>
</Tabs>

For example:

<Tabs>
  <Tab title="Kotlin">
    ```kotlin
    DevRev.startTimer("response-time", properties: {"id": "task-1337"})

    // Perform the task that you want to measure.

    DevRev.endTimer("response-time", properties: {"id": "task-1337"})
    ```
  </Tab>
  <Tab title="Java">
    ```java
    DevRevObservabilityExtKt.startTimer(DevRev.INSTANCE, "response-time", new HashMap<String, String>().put("id", "task-1337"));

    // Perform the task that you want to measure.

    DevRevObservabilityExtKt.endTimer(DevRev.INSTANCE, "response-time", new HashMap<String, String>().put("id", "task-1337"));
    ```
  </Tab>
</Tabs>

### Track screens

The DevRev SDK offers automatic screen tracking to help you understand how users navigate through your app. Although activities and fragments are automatically tracked, you can manually track screens using the following method:

<Tabs>
  <Tab title="Kotlin">
    ```kotlin
    DevRev.trackScreenName(screenName: String)
    ```
  </Tab>
  <Tab title="Java">
    ```java
    DevRevObservabilityExtKt.trackScreenName(DevRev.INSTANCE, String screenName);
    ```
  </Tab>
</Tabs>

For example:

<Tabs>
  <Tab title="Kotlin">
    ```kotlin
    DevRev.trackScreenName("profile-screen")
    ```
  </Tab>
  <Tab title="Java">
    ```java
    DevRevObservabilityExtKt.trackScreenName(DevRev.INSTANCE, "profile-screen");
    ```
  </Tab>
</Tabs>

### Manage screen transitions

The DevRev SDK allows tracking of screen transitions to understand the user navigation within your app.
You can check if a screen transition is in progress and manually update the state using the following methods:

#### Check if the screen is transitioning

<Tabs>
  <Tab title="Kotlin">
    ```kotlin
    val isTransitioning = DevRev.isInScreenTransitioning
    ```
  </Tab>
  <Tab title="Java">
    ```java
    boolean isTransitioning = DevRevObservabilityExtKt.isInScreenTransitioning(DevRev.INSTANCE);
    ```
  </Tab>
</Tabs>

#### Set screen transitioning state

<Tabs>
  <Tab title="Kotlin">
    ```kotlin
    // Mark the transition as started.
    DevRev.setInScreenTransitioning(true)

    // Mark the transition as ended.
    DevRev.setInScreenTransitioning(false)
    ```
  </Tab>
  <Tab title="Java">
    ```java
    // Mark the transition as started.
    DevRevObservabilityExtKt.setInScreenTransitioning(DevRev.INSTANCE, true)

    // Mark the transition as ended.
    DevRevObservabilityExtKt.setInScreenTransitioning(DevRev.INSTANCE, false)
    ```
  </Tab>
</Tabs>

### Track handled exceptions

The DevRev SDK allows you to report handled exceptions from catch blocks using the `sendException` function. This ensures that even if the exception is handled in your app, it will still be logged for diagnostics.

<Tabs>
  <Tab title="Kotlin">
    ```kotlin
    DevRev.sendException(
      exceptionObj: Throwable,
      exceptionTag: String
    )
    ```
  </Tab>
  <Tab title="Java">
    ```java
    DevRevObservabilityExtKt.sendException(
      DevRev.INSTANCE,
      Throwable exceptionObj,
      String exceptionTag
    );
    ```
  </Tab>
</Tabs>

For example:

<Tabs>
  <Tab title="Kotlin">
    ```kotlin
    try {
      // Your code that may produce an exception.
    } catch (e: Throwable) {
      DevRev.sendException(
        exceptionObj = e,
        exceptionTag = "login-failure"
      )
    }
    ```
  </Tab>
  <Tab title="Java">
    ```java
    try {
      // Your code that may throw an exception.
    } catch (Throwable e) {
      DevRevObservabilityExtKt.sendException(
        DevRev.INSTANCE,
        e,
        "login-failure"
      );
    }
    ```
  </Tab>
</Tabs>

## Push notifications

You can configure your app to receive push notifications from the DevRev SDK. The SDK is designed to handle push notifications and execute actions based on the notification's content.

The DevRev backend sends push notifications to your app to notify users about new messages in the Plug support chat.

### Configuration

To receive push notifications, you need to configure your DevRev organization by following the instructions in the [push notifications](../push-notifications) section.

You need to ensure that your Android app is configured to receive push notifications. To set it up, follow the [Firebase documentation](https://firebase.google.com/docs/cloud-messaging/android/client).

### Register for push notifications

<Callout intent="tip">
Push notifications require that the SDK has been configured and the user has been identified (unverified and anonymous users). The user identification is required to send the push notification to the correct user.
</Callout>

The DevRev SDK offers a method to register your device for receiving push notifications. You can register for push notifications using the following method:

<Tabs>
  <Tab title="Kotlin">
    ```kotlin
    DevRev.registerDeviceToken(
      context: Context,
      deviceToken: String,
      deviceId: String
    )
 ```
  </Tab>
  <Tab title="Java">
    ```java
    DevRev.INSTANCE.registerDeviceToken(
      Context context,
      String deviceToken,
      String deviceId
    );
    ```
  </Tab>
</Tabs>

The method requires a device identifier that persists across device restarts and app launches. This could be a Firebase installation ID, Android ID, or a unique system identifier. To obtain the device token for Firebase Cloud Messaging, follow these steps:

1. Use the `FirebaseMessaging` object.
2. Call the `firebaseMessaging.token.await()` method.

This method generates and returns the device token.
```kotlin
val firebaseMessaging = FirebaseMessaging.getInstance()
val token = firebaseMessaging.token.await()
// Use the token as needed
```

### Unregister from push notifications

If your app no longer needs to receive push notifications, you can unregister the device.

Use the following method to unregister the device:

The method requires the device identifier, which should be the same as the one used when registering the device.

<Tabs>
  <Tab title="Kotlin">
      ```kotlin
      DevRev.unregisterDevice(
        context: Context,
        deviceId: String
      )
      ```
  </Tab>
  <Tab title="Java">
    ```java
    DevRev.INSTANCE.unregisterDevice(
      Context context,
      String deviceId
    );
    ```
  </Tab>
</Tabs>

The method requires the device identifier, which should be the same as the one used when registering the device.

### Handle push notifications

The DevRev SDK currently does not support automatic handling of push notifications. To open the Plug chat and manage navigation internally, you must pass the message payload received in the notification to the SDK.

<Tabs>
  <Tab title="Kotlin">
    ```kotlin
    DevRev.processPushNotification(
      context: Context,
      userInfo: String
    )
    ```
  </Tab>
  <Tab title="Java">
    ```java
    DevRev.INSTANCE.processPushNotification(
      Context context,
      String userInfo
    );
    ```
  </Tab>
</Tabs>

To extract the notification payload, do the following:

1. In Firebase Cloud Messaging (FCM), when a push notification is received, it triggers the `onMessageReceived` function in your `FirebaseMessagingService` class.
2. This function receives a `RemoteMessage` object as a parameter, which contains the notification data.
3. The `RemoteMessage` object has a `data` property, which is a map containing key-value pairs of the notification payload.
4. To extract a specific piece of data from the payload, use the key to access the value in the data map.
5. To retrieve the "message" from the payload:

<Tabs>
  <Tab title="Kotlin">
    ```kotlin
    val message = remoteMessage.data["message"]
    ```
  </Tab>
  <Tab title="Java">
    ```java
    String messageData = remoteMessage.getData().get("message");
    ```
 </Tab>
</Tabs>

For example:

<Tabs>
  <Tab title="Kotlin">
    ```kotlin
    class MyFirebaseMessagingService: FirebaseMessagingService {
      // ...

      override fun onMessageReceived(remoteMessage: RemoteMessage) {
        // ...
        val messageData = remoteMessage.data["message"]
        DevRev.processPushNotification(messageData)
      }
    }
    ```
  </Tab>
  <Tab title="Java">
    ```java
    public class MyFirebaseMessagingService extends FirebaseMessagingService {
      // ...

      @Override
      public void onMessageReceived(RemoteMessage remoteMessage) {
        // ...
        String messageData = remoteMessage.getData().get("message");
        DevRev.processPushNotification(messageData);
      }
    }
    ```
 </Tab>
</Tabs>
